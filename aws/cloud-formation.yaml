# Be sure to update the domain's name servers to point to the hosted zone's
# name servers, otherwise DNS resolution won't work. This step is manual
# because the domain isn't managed by CloudFormation.

# Certificates require manual validation. After creating a certificate with
# CloudFormation, you must go to the certificate manager in the AWS console and
# hit the "Create record in Route 53" button.

Parameters:

  Domain:
    Type: String
    Description:
      The root (apex) domain name. You can include the final period after the
      TLD here, but you don't need to.
    Default: monadoc.com

  Image:
    Type: String
    Description:
      The Docker image to use. Note that the tag is set separately. This can
      be pretty much anything, but the image must be public.
    Default: taylorfausak/monadoc

  Port:
    Type: Number
    Description:
      The port number to bind inside the container. It's unlikely that you'll
      need to change this.
    Default: 4444

  Tag:
    Type: String
    Description:
      The Docker image tag to deploy. Usually this is the HEAD of the default
      branch, but it can be any tag that exists for the image in the registry.

Resources:

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-logs-loggroup.html
  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub ${AWS::StackName}-log-group
      RetentionInDays: 30

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html
  Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service:
                - ecs-tasks.amazonaws.com
        Version: 2012-10-17
      Description: Role used to launch ECS tasks.
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
      RoleName: !Sub ${AWS::StackName}-role-${AWS::Region}

  # Unfortunately CloudFormation does not currently support attaching EFS
  # volumes to task definitions. That means we have to jump through some hoops
  # to get that set up. Keep an eye on this issue:
  # <https://github.com/aws/containers-roadmap/issues/825>.
  #
  # Instead of defining a normal `AWS::ECS::TaskDefinition` we have to make a
  # custom resource. Custom resources need to be executed by something, so we
  # have to make a Lambda for that. And doing all this needs the right
  # permissions, so we also have to make a new role. This was all adapted from
  # the following gist:
  # <https://gist.github.com/guillaumesmo/4782e26500a3ac768888daab3c55b139>.
  CustomResourceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: 2012-10-17
      Description: Manages custom task definition resources.
      Policies:
        - PolicyDocument:
            Statement:
            - Action:
                - ecs:DeregisterTaskDefinition
                - ecs:RegisterTaskDefinition
                - logs:CreateLogGroup
                - logs:CreateLogStream
                - logs:PutLogEvents
              Effect: Allow
              Resource: '*'
            - Action:
                - iam:PassRole
              Effect: Allow
              Resource: !GetAtt Role.Arn
          PolicyName: !Sub ${AWS::StackName}-custom-policy
      RoleName: !Sub ${AWS::StackName}-custom-role-${AWS::Region}
  CustomResourceFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          const aws = require('aws-sdk')
          const response = require('cfn-response')
          const ecs = new aws.ECS({apiVersion: '2014-11-13'})
          exports.handler = function(event, context) {
            console.log("REQUEST RECEIVED:\n" + JSON.stringify(event))
            if (event.RequestType === 'Create' || event.RequestType === 'Update') {
              const taskDefinition = event.ResourceProperties.TaskDefinition;
              taskDefinition.containerDefinitions[0].essential = taskDefinition.containerDefinitions[0].essential === 'true';
              ecs.registerTaskDefinition(taskDefinition, function(err, data) {
                if (err) {
                  console.error(err);
                  response.send(event, context, response.FAILED)
                } else {
                  console.log(`Created/Updated task definition ${data.taskDefinition.taskDefinitionArn}`)
                  response.send(event, context, response.SUCCESS, {}, data.taskDefinition.taskDefinitionArn)
                }
              })
            } else if (event.RequestType === 'Delete') {
              ecs.deregisterTaskDefinition({taskDefinition: event.PhysicalResourceId}, function(err) {
                if (err) {
                  if (err.code === 'InvalidParameterException') {
                    console.log(`Task definition: ${event.PhysicalResourceId} does not exist. Skipping deletion.`)
                    response.send(event, context, response.SUCCESS)
                  } else {
                    console.error(err)
                    response.send(event, context, response.FAILED)
                  }
                } else {
                  console.log(`Removed task definition ${event.PhysicalResourceId}`)
                  response.send(event, context, response.SUCCESS)
                }
              })
            } else {
              console.error(`Unsupported request type: ${event.RequestType}`)
              response.send(event, context, response.FAILED)
            }
          }
      Description: Manages custom task definition resources.
      FunctionName: !Sub ${AWS::StackName}-custom-function
      Handler: index.handler
      Role: !GetAtt CustomResourceRole.Arn
      Runtime: nodejs12.x
      Timeout: 30
  CustomTask:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt CustomResourceFunction.Arn
      TaskDefinition:
        cpu: 256
        containerDefinitions:
          - command:
              - monadoc
              - --database=/efs/monadoc.sqlite3
              - --host=*
              - !Sub --port=${Port}
            image: !Sub ${Image}:${Tag}
            name: !Sub ${AWS::StackName}-custom-container
            essential: true
            logConfiguration:
              logDriver: awslogs
              options:
                awslogs-group: !Ref LogGroup
                awslogs-region: !Ref AWS::Region
                awslogs-stream-prefix: !Ref Tag
            mountPoints:
              - containerPath: /efs
                sourceVolume: !Sub ${AWS::StackName}-efs
            portMappings:
              - containerPort: !Ref Port
        executionRoleArn: !Ref Role
        family: !Sub ${AWS::StackName}-custom-task-definition
        memory: 512
        networkMode: awsvpc
        requiresCompatibilities:
          - FARGATE
        volumes:
          - efsVolumeConfiguration:
              fileSystemId: !Ref FileSystem
            name: !Sub ${AWS::StackName}-efs

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-cluster.html
  Cluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: !Sub ${AWS::StackName}-cluster

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc.html
  Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.10.0.0/16
      EnableDnsHostnames: true

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet.html
  Subnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 0
        - Fn::GetAZs: !Ref AWS::Region
      CidrBlock: 10.10.1.0/24
      VpcId: !Ref Vpc
  Subnet2:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Select
        - 1
        - Fn::GetAZs: !Ref AWS::Region
      CidrBlock: 10.10.2.0/24
      VpcId: !Ref Vpc

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html
  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub ${AWS::StackName}-security-group
      GroupDescription: Allows everything.
      SecurityGroupEgress:
        CidrIp: 0.0.0.0/0
        FromPort: -1
        IpProtocol: -1
        ToPort: -1
      SecurityGroupIngress:
        CidrIp: 0.0.0.0/0
        FromPort: -1
        IpProtocol: -1
        ToPort: -1
      VpcId: !Ref Vpc

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-internetgateway.html
  InternetGateway:
    Type: AWS::EC2::InternetGateway

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpc-gateway-attachment.html
  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref Vpc

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route-table.html
  RouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref Vpc

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-route.html
  Route:
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
      RouteTableId: !Ref RouteTable

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-subnet-route-table-assoc.html
  RouteTableAssociation1:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref RouteTable
      SubnetId: !Ref Subnet1
  RouteTableAssociation2:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref RouteTable
      SubnetId: !Ref Subnet2

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html
  Service:
    Type: AWS::ECS::Service
    Properties:
      Cluster: !Ref Cluster
      DesiredCount: 1
      LaunchType: FARGATE
      LoadBalancers:
        - ContainerName: !Sub ${AWS::StackName}-custom-container
          ContainerPort: !Ref Port
          TargetGroupArn: !Ref TargetGroup
      NetworkConfiguration:
        AwsvpcConfiguration:
          AssignPublicIp: ENABLED
          SecurityGroups:
            - !Ref SecurityGroup
          Subnets:
            - !Ref Subnet1
            - !Ref Subnet2
      ServiceName: !Sub ${AWS::StackName}-custom-service
      TaskDefinition: !Ref CustomTask
      PlatformVersion: 1.4.0

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html
  LoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub ${AWS::StackName}-load-balancer
      SecurityGroups:
        - !Ref SecurityGroup
      Subnets:
        - !Ref Subnet1
        - !Ref Subnet2

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPath: /health-check
      Name: !Sub ${AWS::StackName}-target-group
      Port: !Ref Port
      Protocol: HTTP
      TargetType: ip
      VpcId: !Ref Vpc

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html
  Listener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      Certificates:
        - CertificateArn: !Ref OriginCertificate
      DefaultActions:
        - TargetGroupArn: !Ref TargetGroup
          Type: forward
      LoadBalancerArn: !Ref LoadBalancer
      Port: 443
      Protocol: HTTPS

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-route53-hostedzone.html
  HostedZone:
    Type: AWS::Route53::HostedZone
    Properties:
      Name: !Ref Domain

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-route53-recordset.html
  RecordSet:
    Type: AWS::Route53::RecordSet
    Properties:
      AliasTarget:
        DNSName: !GetAtt LoadBalancer.DNSName
        HostedZoneId: !GetAtt LoadBalancer.CanonicalHostedZoneID
      HostedZoneId: !Ref HostedZone
      Name: !Sub www.${Domain}
      Type: A
  OriginRecordSet:
    Type: AWS::Route53::RecordSet
    Properties:
      AliasTarget:
        DNSName: !GetAtt LoadBalancer.DNSName
        HostedZoneId: !GetAtt LoadBalancer.CanonicalHostedZoneID
      HostedZoneId: !Ref HostedZone
      Name: !Sub origin.${Domain}
      Type: A

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-filesystem.html
  FileSystem:
    Type: AWS::EFS::FileSystem

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-mounttarget.html
  MountTarget1:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref FileSystem
      SecurityGroups:
        - !Ref SecurityGroup
      SubnetId: !Ref Subnet1
  MountTarget2:
    Type: AWS::EFS::MountTarget
    Properties:
      FileSystemId: !Ref FileSystem
      SecurityGroups:
        - !Ref SecurityGroup
      SubnetId: !Ref Subnet2

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-efs-accesspoint.html
  AccessPoint:
    Type: AWS::EFS::AccessPoint
    Properties:
      FileSystemId: !Ref FileSystem

  # https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-certificatemanager-certificate.html
  Certificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub www.${Domain}
      ValidationMethod: DNS
  OriginCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub origin.${Domain}
      ValidationMethod: DNS
